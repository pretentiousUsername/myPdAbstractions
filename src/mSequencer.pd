#N canvas 827 239 527 327 12;
#X obj 699 319 metro;
#X obj 699 379 delay;
#X obj 701 439 tgl 21 0 empty empty gate 25 10 0 12 #fcfcfc #000000 #000000 0 1;
#X obj 699 159 inlet timings;
#X obj 959 159 inlet length;
#X obj 1059 159 inlet offset;
#X obj 699 199 /;
#N canvas 733 172 450 300 logicInverter 1;
#X msg 699 559 0;
#X msg 741 559 1;
#X obj 699 499 sel 0 1;
#X floatatom 699 599 5 0 0 0 empty - - 12;
#X obj 699 639 - 1;
#X obj 699 679 abs;
#X floatatom 699 722 5 0 0 0 empty - - 12;
#X obj -843 -1105 inlet;
#X obj 699 779 outlet x';
#X connect 0 0 3 0 empty;
#X connect 1 0 3 0 empty;
#X connect 2 0 0 0 empty;
#X connect 2 1 1 0 empty;
#X connect 3 0 4 0 empty;
#X connect 4 0 5 0 empty;
#X connect 5 0 6 0 empty;
#X connect 6 0 8 0 empty;
#X connect 7 0 2 0 empty;
#X restore 699 499 pd logicInverter;
#X obj 799 159 inlet numberOfRetrigs;
#X text 1199 158 This should work by taking in the timings \, note values \, number of times a part should be retriggered \, and gate on/off offsets in order to make a pretty versatile sequencer. I could just use the `text sequence` object \, but that would be boring., f 43;
#X msg 699 259 tempo \$1 millisecond;
#X text 1199 238 Sequences are read from input tables using a tabread object \, and a counter object from the ELSE library outputs what position the sequencer is at., f 43;
#X obj 579 379 s metroBang_\$0;
#X obj 581 199 r metrobang_\$0;
#X connect 0 0 1 0 empty;
#X connect 0 0 12 0 empty;
#X connect 1 0 2 0 empty;
#X connect 2 0 7 0 empty;
#X connect 3 0 6 0 empty;
#X connect 6 0 10 0 empty;
#X connect 8 0 6 1 empty;
#X connect 10 0 0 0 empty;
#X connect 13 0 10 0 empty;
